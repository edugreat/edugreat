import { Component, OnInit } from '@angular/core';
import { AdminService, CategoryObject, SubjectObject } from '../admin.service';
import { FormControl, FormGroup, Validators } from '@angular/forms';

@Component({
  selector: 'app-upload-test',
  templateUrl: './upload-test.component.html',
  styleUrl: './upload-test.component.css'
})
export class UploadTestComponent implements OnInit{

  

  //an array of test categories received from the server
   // This is used to prepopulate the subject selection input so admin can make a choice that subsequently instantiate the necessary form control
  categories?:string[];

  //an array of test subject received from the server.
  // This is used to prepopulate the category selection input so admin can make a choice that subsequently instantiate the necessary form control
  subjects:string[] = [];

  //An array of number used to prepopulate the duration input selection
  durations = [20, 25, 30, 35, 40, 45, 50, 55, 60];

  //An array of alphabets used to prepopulate the option input selection
  options = ['A', 'B', 'C', 'D', 'E'];

  //An array of 50 numbers used to prepopulate question number input selection
  numberRange?:number[]


  constructor(private adminService:AdminService){}

//Test form for collecting basic information about the test from the admin
  testUploadForm = new FormGroup({
    id: new FormControl<number>(0),//placeholder to avoid exception in the server, though ID is generated by the database. 

    category: new FormControl<string|undefined>(undefined, {
      nonNullable:true,
      validators: Validators.required
    }),

    subject: new FormControl<string|undefined> ({value:undefined, disabled:true},{
      nonNullable:true,
      validators: Validators.required
    }),
    
    title: new FormControl<string|undefined>({value:undefined, disabled:true}, {

      nonNullable:true,
      
      validators: Validators.required
    }),
    duration: new FormControl<string|undefined>({value:undefined, disabled:true}, {
      nonNullable:true,
      validators: Validators.required
    })
  });

   // Question form for collecting qustions from the admin
   questionForm = new FormGroup({

    
    total:new FormControl<string|undefined>({value:undefined, disabled:true},{
      nonNullable:true,
      validators: Validators.required
    }),
    
    index: new FormControl<string|undefined>({value:undefined, disabled:true},{
      nonNullable:true,
      validators: Validators.required
    }),

    text: new FormControl<string|undefined>({value:undefined, disabled:true},{
      nonNullable: true,
      validators: Validators.required
    }),
    
    answer:new FormControl({value:undefined, disabled:true},{
      nonNullable:true,
      validators: Validators.required
    })

  });

  // Form for collecting options for each question asked
  optionForm = new FormGroup({

    letter:new FormControl({value:undefined, disabled:true},{
      nonNullable:true,
      validators: Validators.required
    }),
    text: new FormControl({value:undefined, disabled:true},{
      nonNullable:true,
      validators: Validators.required
    })
  })


  
  ngOnInit(): void {
    this.fetchTestUploadInfo();
    this.fillNumberRange();
    this.adjustFormStatus();
    
   
  }


  
  //get the data required for test upload. Such data include the test category and the subject for which the Test is intended
  private fetchTestUploadInfo(){

    this.adminService.fetchCategory().subscribe((data:CategoryObject)=>{
     
      //assign the the array of levels returnd from this server call to the category property
      this.categories = data._embedded.levels.map(level => level.category);

      const urls:string[] = data._embedded.levels.map(level => level._links.subjects.href);

      urls.forEach(url => this.fetchSubject(url));
      
    })


  }

  private fetchSubject(url:string){

    return this.adminService.fetchSubjects(url).subscribe((data:SubjectObject) =>{
     
       //assign to the subject array property, the returned subject name array of this server
       const subject:string[] =  data._embedded.subjects.map(subject =>subject.subjectName);
       this.subjects.push(...subject);
 

    })

  }

  //populate hthe numberRange array
  private fillNumberRange(){

    this.numberRange =  new Array(50);

   for (let index = 1; index < this.numberRange.length; index++) {
    this.numberRange[index - 1] = index;
    
   }
  }

  
  // dynamically enable or disable some part of the forms depending on the current state of other part of the for.
  //For instance, when category is yet to get selected, other parts of the form should be disabled
  private adjustFormStatus(){
    const categoryInput = this.testUploadForm.get('category')!;
    const subjectInput = this.testUploadForm.get('subject')!;
    const titleInput = this.testUploadForm.get('title')!;
    const durationInput = this.testUploadForm.get('duration')!;

    const totalInput = this.questionForm.get('total')!;
    const indexInput = this.questionForm.get('index')!;
    const problemInput = this.questionForm.get('text')!;
    const answerInput = this.questionForm.get('answer')!;

    const optionInput = this.optionForm.get('letter')!;
    const optionTextInput = this.optionForm.get('text')!;

    //reset the form groups each time the user makes changes on the selected category
    categoryInput.valueChanges.subscribe(currentValue =>{

      subjectInput.reset();
      titleInput.reset();
      durationInput.reset();
      this.questionForm.reset();
      this.optionForm.reset();
      //enable or continue to disable the next field (subject input field) depending on the current value of is field
      currentValue !== undefined ? subjectInput.enable() : subjectInput.disable();
    });

    //reset all inputs below the subject input each time there is a change in the subject selection
    subjectInput.valueChanges.subscribe(currentValue =>{

      titleInput.reset();
      durationInput.reset();
      this.questionForm.reset();
      this.optionForm.reset();
       //enable or continue to disable the next field (title input field) depending on the current value of is field
      currentValue !== undefined ? titleInput.enable() : titleInput.disable();


    })

    titleInput.valueChanges.subscribe(currentValue =>{


      durationInput.reset();
      this.questionForm.reset();
      this.optionForm.reset();
       //enable or continue to disable the next field (title input field) depending on the current value of is field
      (currentValue !== undefined && currentValue.length )? durationInput.enable() : durationInput.disable();


    })

    durationInput.valueChanges.subscribe(currentValue => {

     
      this.questionForm.reset();
      this.optionForm.reset();
      currentValue !== undefined ? totalInput.enable() : totalInput.disable();
    })

    totalInput.valueChanges.subscribe(currentValue => {

      indexInput.reset();
      problemInput.reset();
      answerInput.reset();
      this.optionForm.reset();
      (currentValue !==  undefined && currentValue.length) ? indexInput.enable() : indexInput.disable();
    })

    indexInput.valueChanges.subscribe(currentValue => {
      problemInput.reset();
      answerInput.reset();
      this.optionForm.reset();
      currentValue !==  undefined ? problemInput.enable() : problemInput.disable();
    })

    problemInput.valueChanges.subscribe(currentValue =>{

      answerInput.reset();
      this.optionForm.reset();
      (currentValue !==  undefined && currentValue.length ) ? answerInput.enable() : answerInput.disable();
    })

    answerInput.valueChanges.subscribe(currentValue => {

      this.optionForm.reset();
      currentValue !==  undefined ? optionInput.enable() : optionInput.disable();
      
    })

    optionInput.valueChanges.subscribe(currentValue => {

      currentValue !== undefined ? optionTextInput.enable() : optionTextInput.disable();
    })
  }

}